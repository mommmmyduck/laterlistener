from typing import Optional
from aiogram import F, Router
from aiogram.exceptions import TelegramBadRequest
from mutagen.wave import WAVE
from aiogram.types import Message, LabeledPrice, PreCheckoutQuery
import os
from aiogram.filters import CommandStart, Command
from pydub import AudioSegment
from pydub.silence import detect_nonsilent
import logging
import app.keyboards as kb
from audio_extract import extract_audio

router = Router()


@router.message(CommandStart())
async def cmd_start(message: Message):
    await message.answer(
    "üé§ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞ –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –∞—É–¥–∏–æ!\n\n"
    "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª –∏–ª–∏ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏ —è –ø–µ—Ä–µ–≤–µ–¥—É –µ–≥–æ –≤ —Ç–µ–∫—Å—Ç.\n"
    "–ü–µ—Ä–≤–∞—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ!\n\n"
    "–°—Ç–æ–∏–º–æ—Å—Ç—å: X –∑–∞ –º–∏–Ω—É—Ç—É –∞—É–¥–∏–æ",
    parse_mode="Markdown",
    reply_markup=kb.main
)

#–ê –ù–£–ñ–ï–ù –õ–ò –•–ï–õ–ü?
@router.message(Command('help'))
async def cmd_help(message: Message):
    await message.answer('–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –±–æ—Ç–∞:')

@router.message(F.text == '–í—ã–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ')
async def cmd_audio(message: Message):
    await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à —Ñ–∞–π–ª')


# –û–ë–†–ê–ë–û–¢–ß–ò–ö –ì–°
@router.message(F.voice)
async def handle_voice(message: Message):
    file_id = message.voice.file_id
    await process_audio(message, file_id, "voice")

# –û–ë–†–ê–ë–û–¢–ß–ò–ö –ê–£–î–ò–û
@router.message(F.audio)
async def handle_audio(message: Message):
    file_id = message.audio.file_id
    await process_audio(message, file_id, "audio")

# –û–ë–†–ê–ë–û–¢–ß–ò–ö –í–ò–î–ï–û
@router.message(F.content_type == "video")
async def handle_video(message: Message):
    logging.basicConfig(level=logging.INFO)
    file_id = message.video.file_id
    file_size = message.video.file_size
    logging.info(f"–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {file_size}")
    max_size = 20 * 1024 * 1024
    if file_size < max_size:
        await process_video(message, file_id, "video")
    else:
        await message.reply("–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π, –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä 20–ú–ë, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª")

# –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–†–£–ñ–û–ß–ö–û–í –í –¢–ì
@router.message(F.content_type == "video_note")
async def handle_video(message: Message):
    file_id = message.video_note.file_id
    await process_video(message, file_id, "video_note")

# –û–ë–†–ê–ë–û–¢–ß–ò–ö –§–ê–ô–õ–û–í –ù–ï –Ø–í–õ–Ø–Æ–©–ò–•–°–Ø –ê–£–î–ò–û –ò–õ–ò –ì–° 
@router.message(F.photo | F.document)
async def handle_another_files(message: Message):
    await message.answer("–§–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞—É–¥–∏–æ –∏–ª–∏ –≥–æ–ª–æ—Å–æ–≤—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º")

async def process_video(message: Message, file_id: str, file_type: str):
    logging.basicConfig(level=logging.INFO)
    bot = message.bot
    file = await bot.get_file(file_id)
    file_path = file.file_path

    if not os.path.exists('videos'):
        os.makedirs('videos')
        logging.info("–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –≤–∏–¥–µ–æ")
        
    file_format = get_video_format(file_path)
    if not file_format:
        logging.error(f"–î–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è: {file_path}")
        message.reply("–î–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª")
        
    file_name = f"{file_type}_{message.from_user.id}_{file_id[:8]}{file_format}"
    save_path = os.path.join("videos", file_name)

    await bot.download_file(file_path, destination=save_path)
    logging.info("–°–∫–∞—á–∞–Ω –≤–∏–¥–µ–æ —Ñ–∞–π–ª")

    if not os.path.exists("audios"):
        os.makedirs('audios')
        logging.info("–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç—Ä–∏—è –¥–ª—è –∑–≤—É–∫–æ–≤—ã—Ö –¥–æ—Ä–æ–∂–µ–∫ –≤–∑—è—Ç—ã—Ö –∏–∑ –≤–∏–¥–µ–æ")
        
    audio_file_name = f"audios/audio_{message.from_user.id}_{file_id[:8]}.wav"
    extract_audio(f"videos/{file_name}", audio_file_name, output_format="wav")

    if not await has_audio(audio_file_name):
        logging.error(f"–§–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–≤—É–∫–∞ –∏–ª–∏ –±–∏—Ç—ã–π")
        await message.answer('–§–∞–π–ª —Ç–∏—Ö–∏–π –∏–ª–∏ –±–∏—Ç—ã–π, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∞—É–¥–∏–æ —Ñ–∞–π–ª')
        os.remove(save_path)
        os.remove(audio_file_name)
        return
        
    audio = WAVE(audio_file_name)
    duration = audio.info.length
    logging.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –¥–ª–∏–Ω–∞ –∞—É–¥–∏–æ –¥–æ—Ä–æ–∂–∫–∏: {duration:.2f}")
    await print_price(int(duration), message)



def get_video_format(file_path: str) -> Optional[str]:
    formats = [".webm", ".mp4", ".mov", ".avi", ".mkv"]
    for fmt in formats:
        if file_path.endswith(fmt):
            return fmt
    return None

async def process_audio(message: Message, file_id: str, file_type: str):
    logging.basicConfig(level=logging.INFO)
    try:
        # –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –§–ê–ô–õ–ï
        bot = message.bot
        file = await bot.get_file(file_id)
        file_path = file.file_path    

        # –ò–ú–Ø –§–ê–ô–õ–ê
        file_name = f"{file_type}_{message.from_user.id}_{file_id[:8]}.ogg"
        save_path = os.path.join("downloads", file_name)


        await bot.download_file(file_path, destination=save_path)
        logging.info(f"–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {save_path}")

        # –ü–†–û–í–ï–†–ö–ê –ù–ê –ó–í–£–ö –í –§–ê–ô–õ–ï
        if not await has_audio(save_path):
            logging.error(f"–§–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–≤—É–∫–∞ –∏–ª–∏ –±–∏—Ç—ã–π")
            await message.answer('–§–∞–π–ª —Ç–∏—Ö–∏–π –∏–ª–∏ –±–∏—Ç—ã–π, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∞—É–¥–∏–æ —Ñ–∞–π–ª')
            os.remove(save_path)
            return
        
        duration = message.voice.duration if file_type == "voice" else message.audio.duration
        await print_price(duration, message)
    except Exception as e:
        logging.error(f"Error: {str(e)}")

async def print_price(duration: int, message: Message):
    cost = calculate_cost(duration)  # –°–¢–û–ò–ú–û–°–¢–¨
    prices = [LabeledPrice(label="XTR", amount=cost)] 
    await message.answer(
        f"‚úÖ –§–∞–π–ª –ø–æ–ª—É—á–µ–Ω!\n"
        f"–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration // 60}:{duration % 60:02d} –º–∏–Ω.\n"
        f"–°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} XTR")

    await message.answer_invoice(
        title="–û–ø–ª–∞—Ç–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏",
        description=f"–°—É–º–º–∞: {cost} XTR",
        prices=prices,
        provider_token="",
        payload="trancrib_payment",
        currency="XTR",
        reply_markup=kb.payment_keyboard(cost), 
    )

async def has_audio(audio_path: str, silence_thresh=-50.0, min_silence_len=1000) -> bool:
    audio = AudioSegment.from_file(audio_path)
    nonsilent_ranges = detect_nonsilent(
        audio, 
        min_silence_len=min_silence_len, 
        silence_thresh=silence_thresh
    )
    return len(nonsilent_ranges) > 0

from aiogram.types import PreCheckoutQuery

@router.pre_checkout_query()
async def pre_checkout_handler(pre_checkout_query: PreCheckoutQuery):  
    await pre_checkout_query.answer(ok=True)

@router.message(F.successful_payment)
async def success_payment_handler(message: Message):  
    await message.answer(text="–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à—É –æ–ø–ª–∞—Ç—É!ü§ó")


def calculate_cost(duration_sec: int) -> float:
    cost_per_minute = 1 # –ó–í–Å–ó–î–´
    minutes = max(1, (duration_sec + 59) // 60)  # –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö
    return minutes * cost_per_minute
#–¢–†–ê–ù–°–ö–†–ò–ë–ê–¶–ò–Ø
